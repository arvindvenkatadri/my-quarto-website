{
  "hash": "cf283b0ae19dd992bc92758fd20ea2af",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 23/Nov/2024\ndate-modified: \"2025-07-17\"\ntitle: \"AI by Hand\"\norder: 55\nsummary: \ntags:\n- Neural Nets\n- Back Propagation\n- Gradient\nfilters:\n  - d2\nd2:\n  layout: elk\n  theme: \"CoolClassics\"\n  sketch: true\n\n---\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n## Training the Neural Network\n\nLet us head off to this website and build a small Neural network by hand. \n\n<https://student.desmos.com/join/6x8gme>\n\nEvery time we give the network a new \"sketch\" to train with, potentially **all** network connections are updated, using backpropagation. \n\n\n### Cost-Gradient for each Weight\n\n1. The cost function was the squared error averaged over all $n$ neurons:\n\n$$\n\\begin{align}\nC(W, b) &= \\frac{1}{2n}\\sum^{n ~ neurons}_{i=1}e^2(i)\\\\\n\\end{align}\n$${#eq-cost-function}\n\n\n\n2. ***Serious Magic***: We want to differentiate this sum for **each Weight**. Before we calculate $\\frac{dC}{dW^l_{jk}}$, we realize that *any weight* $W^l_{jk}$ connects only as input to **one neuron** $k$, which outputs $a_k$. No other neuron-terms in the above summation depend upon this specific Weight, so the summation becomes *just one term*, pertaining to activation-output, say $a_k$!\n\n$$\n\\begin{align}\n\\frac{d~C}{d~\\color{orange}{\\pmb{W^l_{jk}}}} &= \\large\\frac{d}{d~\\color{orange}{\\pmb{W^l_{jk}}}}\\Bigg({\\frac{1}{2n}\\sum^{all~n~neurons}_{i=1}(e_i)^2}~\\Bigg)\\\\\n\\\\\n&= \\frac{\\color{skyblue}{\\large{e^l_k}} }{n} ~ * \\frac{d}{d~\\color{orange}{\\pmb{W^l_{jk}}}} ~ \\Bigg(\\pmb{\\color{red}{\\Large{{e^{l}_k}}}} ~ \\Bigg) ~~only~~k^{th}~neuron~l^{th}~layer\\\\\n\\\\\n&= \\frac{\\color{skyblue}{\\large{e^l_k}} }{n} ~ * ~ {\\frac{d}{d~\\color{orange}{\\pmb{W^l_{jk}}}}\\bigg(\\Large{\\color{red}{a^{l}_k - d^l_k}}}\\bigg)\n\\end{align}\n$$\n\n3. Now, the relationship between $a^{l}_k$ and $W^l_{jk}$ involves the sigmoid function. (And $d_k$ is not dependent upon anything!)\n\n$$\n\\begin{align}\n\\color{red}{\\pmb{a^l_k}} ~ &= \\sigma~\\bigg(\\sum^{neurons~in~l-1}_{j=1} \\pmb{\\color{orange}{W^l_{jk}}} ~ * ~{a^{l-1}_j + b^l_j}\\bigg)\\\\\n&= \\color{red}{\\sigma(everything)}\\\\\n\\end{align}\n$$\n\n4. We also know \n$$\n\\large{\\frac{d\\sigma(x)}{dx}} = \\sigma(x) * \\big(1 - \\sigma(x)\\big)\n$$ \n\n5. **Final Leap**: Using the great [chain rule for differentiation](https://en.wikipedia.org/wiki/Derivative#Rules_for_basic_functions), we obtain:\n\n::: column-screen-inset-right\n$$\n\\begin{align}\n\\frac{d~C}{d~\\color{orange}{\\pmb{W^l_{jk}}}} &= \\frac{\\color{skyblue}{\\large{e^l_k}} }{n} ~ * ~ {\\frac{d}{d~\\color{orange}{\\pmb{W^l_{jk}}}}\\bigg(\\Large{\\color{red}{a^{l}_k - d^l_k}}}\\bigg)\\\\\n&= \\frac{\\color{skyblue}{\\large{e^l_k}} }{n} ~ * ~\\frac{d~\\color{red}{\\pmb{a^l_k}}}{d~\\color{orange}{\\pmb{W^l_{jk}}}}\\\\\n&= \\frac{\\color{skyblue}{\\large{e^l_k}} }{n} ~ *\\frac{d~ \\color{red}{\\sigma(everything)}}{d~\\color{orange}{\\pmb{W^l_{jk}}}}\\\\\n\\\\\n&= \\frac{\\color{skyblue}{\\large{e^l_k}} }{n} ~ * \\sigma(everything) * (1 -\\sigma(everything)) * \\frac{d(everything)}{d~\\color{orange}{\\pmb{W^l_{jk}}}}~~ \\text{Applying Chain Rule!}\\\\\n&= \\huge{\\frac{\\color{skyblue}{\\large{e^l_k}} }{n} ~ * \\color{red}{~a^{l-1}_k} * ~\\\\\n\\large{\\sigma~\\bigg(\\sum^{neurons~in~l-1}_{j=1} \\pmb{\\color{orange}{W^l_{jk}}} ~ * ~ {a^{l-1}_j + b^l_j}\\bigg) * \\\\\n\\bigg(1 - \\sigma~\\bigg(\\sum^{neurons~in~l-1}_{j=1} \\pmb{\\color{orange}{W^l_{jk}}} ~ * ~ {a^{l-1}_j + b^l_j}\\bigg)\\bigg)}}\n\\end{align}\n$${#eq-gradient}\n\n:::\n\n\n\nHow to understand this monster equation intuitively? Let us first draw a diagram to visualize the components:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.d2 .cell-code}\ntitle: Cost Gradient Interpreted {\n  shape: text\n  near: top-center\n  style: {\n    font-size: 60\n    italic: true\n  }\n}\ndirection: right\ngrid-columns: 3\ngrid-gap: 400\n\nlayer-1: Layer: L-1 Index-j {\n  grid-columns: 1\n  grid-gap: 100\n  j {shape: circle\n     style: {\n      font-size: 60\n      fill: orange\n      stroke-width:6\n    }}\n  2 {shape: circle\n     style: {\n      font-size: 45\n    }}\n  3 {shape: circle\n     style: {\n      font-size: 45\n    }}\n}\nlayer-2: Layer: L Index-k {\n  grid-columns: 1\n  grid-gap: 100\n  h1 {shape: circle\n     style: {\n      font-size: 45\n    }}\n  k {shape: circle\n     style: {\n      font-size: 60\n      fill: orange\n      stroke-width:6\n    }}\n  h3 {shape: circle\n     style: {\n      font-size: 45\n    }}\n}\n\nlayer-3: {\n  grid-columns: 1\n  grid-gap: 100\n  style: {\n    opacity: 0\n  }\n    e12: \"e12\" {shape: circle\n     style: {\n      font-size: 45\n      stroke: white\n      fill: white\n    }}\n    e22: \"ekL\" {shape: circle\n     style: {\n      font-size: 80\n      stroke: white\n      fill: lightblue\n    }}\n    e32: \"e32\" {shape: circle\n     style: {\n      font-size: 45\n      stroke: white\n      fill: white\n     }\n     }\n}\nlayer-1.j -> layer-2.k: Wjk {\n  source-arrowhead: {\n    label: a(L-1)j\n    style {\n    font-color: red\n    }\n  }\n  style: {\n    fill: orange\n    font-size: 80\n    stroke: FireBrick\n    stroke-width: 9\n    animated: true\n  }\n}\n#layer-1.j -> layer-2.h1\n#layer-1.j -> layer-2.h3\nlayer-1.2 -> layer-2.k: W2k {\n  source-arrowhead.label: a(L-1)2\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: FireBrick\n    stroke-width: 9\n    animated: true\n  }\n}\n#layer-1.2 -> layer-2.h1\n#layer-1.2 -> layer-2.h3\nlayer-1.3 -> layer-2.k: W3k {\n  source-arrowhead.label: a(L-1)3\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: FireBrick\n    stroke-width: 9\n    animated: true\n  }\n}\n#layer-1.3 -> layer-2.h1\n#layer-1.3 -> layer-2.h3\n\nlayer-2.k -> layer-3.e22 { style: {stroke-width: 9\n         stroke: FireBrick}}\nlayer-2.h1 -> layer-3.e12\nlayer-2.h3 -> layer-3.e32\n\n```\n:::\n\n\nLet us take the *Weight* $Wjk$. It connects neuron $j^{l-1}$ with neuron $k^l$, using the activation $a^{l-1}_j$. The relevant output *error* ( that contributes to the Cost function) is $e^l_{k}$.\n\n- The product $\\large{\\color{red}{a^{l-1}_j} ~ * ~ \\color{lightblue}{e^l_k}}$ is **like a correlation product** of the two quanties at the input and output of the neuron $k$. This product contributes to a sense of *slope*: the larger either of these, larger is the Cost-slope going from neuron $j$ to $k$.\n- How do we account for the magnitude of the *Weight* $Wjk$ itself? Surely that matters! Yes, but note that $Wjk$ is entwined with the remaining inputs and weights via the $\\sigma$ function term!  We must differentiate that and put that differential into the product! That gives is the two other product terms in the formula above which involve the sigmoid function.\n\nSo, monster as it is, the formula is quite intuitive and even beautiful!\n\n\n\n### What does this Gradient Look Like?\n\n\n\n::: {.cell layout-align=\"center\" warn='false'}\n\n:::\n\n\nThis gradient is calculated (in vector fashion) for **all** weights. \n\n### How Does the NN Use this Gradient?\n\nSo now that we have the gradient of *Cost vs $W^l_{jk}$*, we can adapt $W^l_{jk}$ by moving a small tuning step in the **opposite direction**:\n\n$$\nW^l_{jk}~|~new = W^l_{jk}~|~old - \\alpha * gradient\n$${#eq-Wljk-adaptation}\n\nand we adapt all weights in opposition to their individual cost gradient. The parameter $\\alpha$ is called the **learning rate**.\n\nYes, but not all neurons have a *desired output*; so what do we use for error?? Only the output neurons have a desired output!!\n\nThe **backpropagated error**, peasants! Each neuron has already \"received\" its share of error, which is converted to Cost, whose gradient wrt all input weights of the specific neuron is calculated using @eq-gradient, and each weight thusly adapted using @eq-Wljk-adaptation.\n\n\n## Here Comes the ~~Rain~~ Maths Again!\n\nNow, we are ready (maybe?) to watch these two very beautifully made videos on Backpropagation. One is of course from Dan Shiffman, and the other from Grant Sanderson a.k.a. 3Blue1Brown.\n\n:::: {.columns}\n\n::: {.column width=\"48%\"}\n{{< video https://youtu.be/QJoa0JYaX1I?list=PLRqwX-V7Uu6Y7MdSCaIfsxc561QI0U0Tb >}}\n:::\n\n::: {.column width=\"4%\"}\n:::\n\n::: {.column width=\"48%\"}\n{{< video https://youtu.be/tIeHLnjs5U8?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi >}}\n:::\n::::\n\n## Gradient Descent in Code\n\n::: {.panel-tabset .nav-pills style=\"background: whitesmoke \"}\n\n### Using p5.js\n\n\n### Using R\nUsing `torch`.\n\n:::\n\n\n## References\n\n1. Tariq Rashid. *Make your own Neural Network*. [PDF Online](https://github.com/harshitkgupta/StudyMaterial/blob/master/Make%20Your%20Own%20Neural%20Network%20(Tariq%20Rashid)%20-%20%7BCHB%20Books%7D.pdf)\n1. Mathoverflow. *Intuitive Crutches for Higher Dimensional Thinking*. <https://mathoverflow.net/questions/25983/intuitive-crutches-for-higher-dimensional-thinking>\n1. Interactive Backpropagation Explainer <https://xnought.github.io/backprop-explainer/>\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}