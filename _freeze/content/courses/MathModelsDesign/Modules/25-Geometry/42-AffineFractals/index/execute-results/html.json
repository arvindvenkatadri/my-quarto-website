{
  "hash": "097438147f9c0293cc40a154974e8ca1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: <iconify-icon icon=\"mdi:reiterate\" width=\"1.2em\" height=\"1.2em\"></iconify-icon> <iconify-icon icon=\"gravity-ui:function\" width=\"1.2em\" height=\"1.2em\"></iconify-icon> Affine Transformation Fractals\nsubtitle: \"Created in Translation\"\nsubject: \"\"\nabstract: \"\"\ndate: 28/Jan/2025\ndate-modified: \"2025-07-29\"\norder: 42\ncategories:\n- Iterated Functions\n- Fractals\n- Affine Transformations\n- Barnsley\nbibliography: \n  - grateful-refs.bib\n  - references.bib\ncitation: true\neditor: \n  markdown: \n    wrap: 72\nfilters:\n  - d2\nd2:\n  layout: elk\n  theme: \"CoolClassics\"\n  sketch: true\n---\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n## {{< iconify icons8 idea >}} Inspiration\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=2100}\n:::\n:::\n\nThis is a mathematically created fern! It uses, (gasp!) repeated matrix multiplication and addition! \n\nWe'll see.\n\n## Introduction\n\nThe *self-similarity* of fractals suggests that we could create new\nfractals from a basic shape using the following procedure:\n\n1.  Start with a basic shape, e.g. a rectangle\n2.  Define a set of transformations: scaling / mirroring / translation /\n    combination (say n scaled+rotated replicates)\n3.  Run these transformations on the basic shape\n4.  Feed the output back to the input ( Classic IFR )\n5.  Wait for the pattern to emerge.\n\nSee the figure below to get an idea of this process.\n\n![Emerging Fractal](../../../../../materials/images/Emerging-Barnesly.png){#fig-emerging-barnesly}\n\nWell, this works, provided the transformations include significant\namounts of scaling (i.e. **reduction in size**). You can imagine that\nif the basic shape does not shrink fast enough, the pattern converges\nvery slowly and would remain ***chunky*** even after a large number of\niterations.\n\nSecondly, the number of operations quickly becomes exponentially high,\nas each stage creates n-fold computation increase. Indeed, if we run $d$\niterations, then the computations scale as $n^d$, which can very quickly\nbecome out of hand!!\n\nSo what to do? Just like with the\n[DeepSeek-R1](https://arxiv.org/abs/2501.12948) algorithm that\nsimplified a great deal of AI algorithms, we have recourse to what is\ncalled the [**Barnsley\nAlgorithm**](https://mathematica.stackexchange.com/questions/124919/construction-steps-of-barnsleys-fern).\nNOTE: especially note the terrific pictures on this stackexchange page!\n\nFirst let us understand what are ***Affine Transformations*** and then\nbuild our fractals.\n\n## What is an Affine Transformation?\n\nAffine Transformations are defined as a transformations of a space that\nare:\n\n-   linear (no nonlinear functions of an x-coordinate, say $e^x$)\n-   reversible.\n\nAffine transformations can be represented by matrices which multiply the\ncoordinates of a shape in space. Multiple transformations can be\nunderstood a series of matrix multiplications, and can indeed be\ncollapsed into a **SINGLE** matrix multiplication of the coordinates of the shape.\n\nSee this webpage at Mathigon to get an idea of [**rigid transformations of shape.**](https://mathigon.org/course/transformations/rigid#transformations)\n\n## Some Examples of Affine Transformations\n\n![](https://i.pinimg.com/originals/b6/4d/88/b64d88b5898ffff0885db0ff9f1ccb27.png)\n\nHere are some short videos of affine transformations:\n\n::: {layout-nrow=\"3\"}\n\n::: {#fig-1}\n\n{{< video ../../../../../materials/images/a11_square_white.mp4 title=\"Scaling Along X\" >}}\n\nScaling Along X\n\n:::\n\n\n::: {#fig-2}\n{{< video ../../../../../materials/images/a22_square_white.mp4 title=\"Scaling Along Y\" >}}\n\nScaling Along Y\n\n:::\n\n::: {#fig-3}\n\n{{< video ../../../../../materials/images/a12_square_white.mp4 title=\"Shearing Along X\">}}\n\nShearing Along X\n\n:::\n\n::: {#fig-4}\n{{< video ../../../../../materials/images/a21_square_white.mp4 title=\"Shearing Along Y\">}}\n\nShearing Along Y\n\n:::\n\n::: {#fig-5}\n{{< video ../../../../../materials/images/a13_square_white.mp4 title=\"Translation Along X\">}}\n\nTranslation Along X\n\n:::\n\n::: {#fig-6}\n{{< video ../../../../../materials/images/a23_square_white.mp4 title=\"Translation Along Y\">}}\n\nTranslation Along Y\n\n:::\n:::\n\n\n## Designing with Affine Transformations\n\nSo how do we use these Affine Transformations? Let us paraphrase what\n[Gary William\nFlake](https://mitpress.mit.edu/9780262561273/the-computational-beauty-of-nature/)\nsays in his book *The Computational Beauty of Nature*:\n\nIf $p$ is a point in space, and its *affine transformation(s)* is\n$L(p$), then:\n\n-   If $p$ is on the final fractal, then so is $L(p)$;\n-   If $p$ is **not** part of the final fractal, then $L(p)$ will be\n    atleast closer to the final fractal than $p$ itself.\n\nThese ideas give us our final algorithm for *designing a fractal with\naffine transformations*.\n\n-   Start with any point $p$\n-   Pick a (set of) Affine transformations $L_i(p)$ that allow us to\n    imagine the final shape\n-   Take the *affine transformation* $L_i(p)$ of point $p$. Choose $i$\n    at random!\n-   Use an IFR: pipe the result back into the input\n-   Make a large number of iterations\n-   Plot all intermediate points that come out of the IFR\n\nWith this approach, the points rapidly land up on the fractal which\nbuilds up over multiple iterations. We can start anywhere in space and\nit will still converge.\n\nThe additional feature of the Barnsley algorithm is the **randomness**:\nsince most fractals use not one but several affine transformations to\ncreate a multiplicity of forms, at each iteration we can randomly choose\nbetween them!\n\nThe block diagram of the Barnsley Algorithm looks like this:\n\n\n::: {.cell}\n\n```{.d2 .cell-code}\ntitle: Barnsley Fractal Algorithm {\n  shape: text\n  near: top-center\n  style: {\n    font-size: 60\n    italic: true\n  }\n}\ndirection: right\n\nin: \"\" {shape: circle\n     style: {\n      font-size: 45\n      stroke: white\n      fill: white\n     }}\nout: \"\" {shape: circle\n     style: {\n      font-size: 45\n      stroke: white\n      fill: white\n    }}\nRandom Choice {shape: circle\n     style: {\n      font-size: 45\n    }}\n\n  Af1 {shape: circle\n     style: {\n      font-size: 45\n    }}\n  Af2 {shape: circle\n     style: {\n      font-size: 45\n    }}\n  Af3 {shape: circle\n     style: {\n      font-size: 45\n     }}\n  Af4 {shape: circle\n     style: {\n      font-size: 45\n    }}\n\nOutput {shape: circle\n     style: {\n      font-size: 45\n    }}\nRandom Choice -> Af1: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: Blue\n    stroke-width: 9\n    animated: true\n  }\n}\nRandom Choice -> Af2: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: Blue\n    stroke-width: 9\n    animated: true\n  }\n}\nRandom Choice -> Af3: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: Blue\n    stroke-width: 9\n    animated: true\n  }\n}\nRandom Choice -> Af4: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: Blue\n    stroke-width: 9\n    animated: true\n  }\n}\n\nAf1 -> Output: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: Blue\n    stroke-width: 9\n    animated: true\n  }\n}\nAf2 -> Output: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: Blue\n    stroke-width: 9\n    animated: true\n  }\n}\nAf3 -> Output: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: Blue\n    stroke-width: 9\n    animated: true\n  }\n}\nAf4 -> Output: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: Blue\n    stroke-width: 9\n    animated: true\n  }\n}\n\nin -> Random Choice: {\n  source-arrowhead.label: \"input\"\n  style: {\n    stroke-width: 9\n    font-size: 25\n  }\n}\nout -> Random Choice: Recursion: {\n  source-arrowhead.label: \"\"\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: FireBrick\n    stroke-width: 9\n    animated: true\n  }\n}\nOutput -> out: {\n  source-arrowhead.label: \"\"\n  style: {\n    stroke-width: 9\n    font-size: 25\n  }\n}\nexplanation: |md\n  # Affine Transformations\n  The Affine Transformations are\\\n  of the form AX + B and are\\\n  randomly chosen at each iteration.\\\n  Probabilities can be assigned by the user.\n| {\n  near: center-left\n  style: {\n  font-size: 40\n  italic: false\n  }\n}\n\n```\n:::\n\n\n::: {.panel-tabset .nav-pills style=\"background: whitesmoke;\"}\n\n### Using p5.js\n\n<iframe width=\"780px\" height=\"600px\"\nsrc=\"https://editor.p5js.org/codingtrain/full/G4V940Y8V\">\n</iframe>\n\nHow to understand this sketch? Here is Dan Shiffman again!\n\n{{< video https://youtu.be/JFugGF1URNo >}}\n\n### Using R\n\nIn the code below, the Affine transformations $Af_i$ are of the form\n\n$$\nAF_i = A_i * X + B_i, ~ i = 1...4\n$${#eq-barnsley-fern-affine-transformation}\n\n\nwith four options each for matrix $A$ and matrix $B$, and $X = (x,y)$, the current point coordinates (seed input, then output feedback for recursion). There are 50000 iterations performed and at each interation, a random A and a random B are picked to provide the Affine Transformation for that iteration. \n\nThe starting \"seed point\" is simply $X = (0,0)$.\n\nThe probabilities with which each affine transformation is chosen are not all equal; these can be tweaked to see the effect on the fractal. \n\nThe four options for the $A_i$ matrices are:\n\n::: {layout-nrow=\"2\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nA <- vector(mode = \"list\", length = 4)\n# Four Affine translation Matrices\nA[[1]] <- matrix(c(0, 0, 0, 0.18), nrow = 2)\nA[[2]] <- matrix(c(0.85, -0.04, 0.04, 0.85), nrow = 2)\nA[[3]] <- matrix(c(0.2, 0.23, -0.26, 0.22), nrow = 2)\nA[[4]] <- matrix(c(-0.15, 0.36, 0.28, 0.24), nrow = 2)\nas_sym(A[[1]])\nas_sym(A[[2]])\nas_sym(A[[3]])\nas_sym(A[[4]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc: ⎡0   0  ⎤\n   ⎢       ⎥\n   ⎣0  0.18⎦\nc: ⎡0.85   0.04⎤\n   ⎢           ⎥\n   ⎣-0.04  0.85⎦\nc: ⎡0.2   -0.26⎤\n   ⎢           ⎥\n   ⎣0.23  0.22 ⎦\nc: ⎡-0.15  0.28⎤\n   ⎢           ⎥\n   ⎣0.36   0.24⎦\n```\n\n\n:::\n:::\n\n:::\n\n\n$$\n\\begin{bmatrix} \n0.00 & 0.00 \\\\ \n0.00 & 0.18 \\\\ \n\\end{bmatrix}\n\n$$ {#eq-A1}\n\n$$\n\\begin{bmatrix} \n 0.85 &  0.04 \\\\ \n-0.04 &  0.85 \\\\ \n\\end{bmatrix}\n\n$$ \n\n$$\n\\begin{bmatrix} \n 0.20 & -0.26 \\\\ \n 0.23 &  0.22 \\\\ \n\\end{bmatrix}\n\n$$ \n\n$$\n\\begin{bmatrix} \n-0.15 &  0.28 \\\\ \n 0.36 &  0.24 \\\\ \n\\end{bmatrix}\n\n$$ \n\n\n\n$$\n\\mathbf{X} = \\mathbf{U} \\mathbf{\\Lambda} \\mathbf{V}\n$$ {#eq-svn}\n\n\n\n$$\n\\begin{bmatrix} \n0.00 & 0.00 \\\\ \n0.00 & 0.18 \\\\ \n\\end{bmatrix}\n\n$$ {#eq-A1}\n\n\nAnd the four options for the $B_i$ matrices are: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Four Simple translation Matrices\nb <- vector(mode = \"list\", length = 4)\nb[[1]] <- matrix(c(0, 0))\nb[[2]] <- matrix(c(0, 1.6))\nb[[3]] <- matrix(c(0, 1.6))\nb[[4]] <- matrix(c(0, 0.54))\nas_sym(b[[1]])\nas_sym(b[[2]])\nas_sym(b[[3]])\nas_sym(b[[4]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc: [0  0]ᵀ\nc: [0  1.6]ᵀ\nc: [0  1.6]ᵀ\nc: [0  0.54]ᵀ\n```\n\n\n:::\n:::\n\n\nBy randomly choosing any of the $16$ resulting transformations, with different but fixed probablilities, we compute and render the Barnsley fern:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Iteratively build the fern\ntheme_set(theme_custom())\n#\nn <- 50000\nx <- numeric(n)\ny <- numeric(n)\nx[1] <- 0\ny[1] <- 0 # Starting point (0,0). Can be anything!\n\nfor (i in 1:(n - 1)) {\n  # Randomly sample the 4 + 4 translations based on a probability\n  # Change these to try different kinds of ferns\n  trans <- sample(1:4, prob = c(.02, .9, .09, .08), size = 1)\n\n  # Translate **current** xy based on the selected translation\n  # Apply one of 16 possible affine transformations\n  xy <- A[[trans]] %*% c(x[i], y[i]) + b[[trans]]\n  x[i + 1] <- xy[1] # Save x component\n  y[i + 1] <- xy[2] # Save y component\n}\n# Plot this baby\n# plot(y,x,col= \"pink\",cex=0.1)\ngf_point(y ~ x,\n  colour = \"lightgreen\", size = 0.02,\n  title = \"Barnsley Fern\"\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=2100}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nX <- matrix(c(5, 5), nrow = 2)\nas_sym(A[[1]])\nas_sym(X)\nas_sym(A[[1]]) %*% as_sym(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc: ⎡0   0  ⎤\n   ⎢       ⎥\n   ⎣0  0.18⎦\nc: [5  5]ᵀ\nc: [0  0.9]ᵀ\n```\n\n\n:::\n\nVertical movement with Shrinkage\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nX <- matrix(c(5, 5), nrow = 2)\nas_sym(A[[2]])\nas_sym(X)\nas_sym(A[[2]]) %*% as_sym(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc: ⎡0.85   0.04⎤\n   ⎢           ⎥\n   ⎣-0.04  0.85⎦\nc: [5  5]ᵀ\nc: [4.45  4.05]ᵀ\n```\n\n\n:::\n\nModest Shrinkage of Both X and Y, X more than Y\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nX <- matrix(c(5, 5), nrow = 2)\nas_sym(A[[3]])\nas_sym(X)\nas_sym(A[[3]]) %*% as_sym(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc: ⎡0.2   -0.26⎤\n   ⎢           ⎥\n   ⎣0.23  0.22 ⎦\nc: [5  5]ᵀ\nc: [-0.3  2.25]ᵀ\n```\n\n\n:::\n\nLarge Shrinkage of Both X and Y, Y more than X\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nX <- matrix(c(5, 5), nrow = 2)\nas_sym(A[[4]])\nas_sym(X)\nas_sym(A[[4]]) %*% as_sym(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc: ⎡-0.15  0.28⎤\n   ⎢           ⎥\n   ⎣0.36   0.24⎦\nc: [5  5]ᵀ\nc: [0.65  3.0]ᵀ\n```\n\n\n:::\n\nShrinkage of Both X and Y, X more than Y\n:::\n\n\n:::\n\n\n## {{< iconify mingcute thought-line >}} Wait, But Why?\n\nOK, so **why** did this become a fern??\n\nIf we look at the list of affine transformations, we see that there are essentially 4 movements possible: <https://en.wikipedia.org/wiki/Barnsley_fern>\n\n- a simple ***vertical*** y-axis movement, with shrinkage\n- a gentle rotation with very little shrinkage\n- a rotation to the right with shrinkage\n- a rotation to the left with shrinkage\n\nThe second transformation is the one most commonly used!! The others are relatively rarely used! So the points slowly slope to the right and do now get squashed up close to the start: they retain sufficient size in (x,y) coordinates for the fern to slowly spread to the right. \n\nSo we can design the affine transformations based on an intuition of how  **we might draw** the fractal by hand, say larger strokes to the right, smaller to the left etc, and and decide on the frequency of strokes based on how often these strokes might be used in drawing.\n\n\n## {{< iconify ooui references-ltr >}} References\n\n1.  Ryan Bradley-Evans. (Oct 7, 2020). *Barnsley’s Fern Fractal in R*.\n    <https://astro-ryan.medium.com/barnsleys-fern-fractal-in-r-e52a357e23db>\n1.  Affine Transformations @ [The Algorithm Archive](https://www.algorithm-archive.org).\n<https://www.algorithm-archive.org/contents/affine_transformations/affine_transformations.html>\n1. Iterated Function systems @ [The Algorithm Archive](https://www.algorithm-archive.org)<https://www.algorithm-archive.org/contents/IFS/IFS.html>\n1. p5.js Tutorial: Coordinates and Transformations. <https://p5js.org/tutorials/coordinates-and-transformations/>\n1. The Coding Train: Algorithmic Botany. <https://thecodingtrain.com/tracks/algorithmic-botany>\n1. Barnsley Fern @ Wikipedia <https://en.wikipedia.org/wiki/Barnsley_fern>\n\n\n::: {#refs style=\"font-size: 60%;\"}\n###### {{< iconify lucide package-check >}} R Package Citations\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nPackage   Version   Citation \n--------  --------  ---------\ncaracas   2.1.1     @caracas \nmatlib    1.0.0     @matlib  \n\n\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}